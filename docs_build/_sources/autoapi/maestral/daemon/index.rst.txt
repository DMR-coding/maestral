:mod:`maestral.daemon`
======================

.. py:module:: maestral.daemon

.. autoapi-nested-parse::

   This module defines functions to start and stop the sync daemon and retrieve proxy
   objects for a running daemon.



Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   maestral.daemon.Stop
   maestral.daemon.Start
   maestral.daemon.Lock
   maestral.daemon.MaestralProxy



Functions
~~~~~~~~~

.. autoapisummary::

   maestral.daemon.serpent_deserialize_api_error
   maestral.daemon.maestral_lock
   maestral.daemon.sockpath_for_config
   maestral.daemon.lockpath_for_config
   maestral.daemon.get_maestral_pid
   maestral.daemon.is_running
   maestral.daemon.start_maestral_daemon
   maestral.daemon.start_maestral_daemon_process
   maestral.daemon.stop_maestral_daemon_process


.. py:class:: Stop

   Bases: :class:`enum.Enum`

   Enumeration of daemon exit results.

   :cvar Ok: Daemon quit successfully.
   :cvar Killed: Daemon process was killed.
   :cvar NotRunning: Daemon was not running.
   :cvar Failed: Could not shut down daemon.


.. py:class:: Start

   Bases: :class:`enum.Enum`

   Enumeration of daemon start results.

   :cvar Ok: Daemon started successfully.
   :cvar AlreadyRunning: Daemon was already running.
   :cvar Failed: Could not start daemon.


.. function:: serpent_deserialize_api_error(class_name: str, d: dict) -> MaestralApiError

   Deserializes a :class:`errors.MaestralApiError`.

   :param class_name: Name of class to deserialize.
   :param d: Dictionary of serialized class.
   :returns: Class instance.


.. py:class:: Lock(name: str, lock_path: Optional[str] = None)

   A inter-process and inter-thread lock. This reuses uses code from oslo.concurrency
   but provides non-blocking acquire. Use the :meth:`singleton` class method to
   retrieve an existing instance for thread-safe usage.

   .. method:: singleton(cls, name: str, lock_path: Optional[str] = None) -> 'Lock'
      :classmethod:

      Retrieve an existing lock object with a given 'name' or create a new one. Use
      this method for thread-safe locks.

      :param name: Name of lock file.
      :param lock_path: Directory for lock files. Defaults to the temporary directory
          returned by :func:`tempfile.gettempdir()` if not given.


   .. method:: acquire(self) -> bool

      Attempts to acquire the given lock.

      :returns: Whether or not the acquisition succeeded.


   .. method:: release(self) -> None

      Release the previously acquired lock.


   .. method:: locked(self) -> bool

      Checks if the lock is currently held by any thread or process.


   .. method:: locking_pid(self) -> Optional[int]

      Returns the PID of the process which currently holds the lock or ``None``. This
      should work on macOS, OpenBSD and Linux but may fail on some platforms. Always
      use :meth:`locked` to check if the lock is held by any process.

      :returns: The PID of the process which currently holds the lock or ``None``.



.. function:: maestral_lock(config_name: str) -> Lock

   Returns an inter-process and inter-thread lock for Maestral. This is a wrapper
   around :class:`Lock` which fills out the appropriate lockfile name and directory for
   the given config name.


.. function:: sockpath_for_config(config_name: str) -> str

   Returns the unix socket location to be used for the config. This should default to
   the apps runtime directory + 'CONFIG_NAME.sock'.


.. function:: lockpath_for_config(config_name: str) -> str

   Returns the lock file location to be used for the config. This should default to
   the apps runtime directory + 'CONFIG_NAME.lock'.


.. function:: get_maestral_pid(config_name: str) -> Optional[int]

   Returns Maestral's PID if the daemon is running, ``None`` otherwise.

   :param config_name: The name of the Maestral configuration.
   :returns: The daemon's PID.


.. function:: is_running(config_name: str) -> bool

   Checks if a daemon is currently running.

   :param config_name: The name of the Maestral configuration.
   :returns: Whether the daemon is running.


.. function:: start_maestral_daemon(config_name: str = 'maestral', log_to_stdout: bool = False, start_sync: bool = False) -> None

   Starts the Maestral daemon with event loop in the current thread. Startup is race
   free: there will never be two daemons running for the same config.

   Wraps :class:`main.Maestral` as Pyro daemon object, creates a new instance and
   starts an asyncio event loop to listen for requests on a unix domain socket. This
   call will block until the event loop shuts down. When this function is called from
   the main thread on macOS, the asyncio event loop uses Cocoa's CFRunLoop to process
   event. This allows integration with Cocoa frameworks which use callbacks to process
   use input such as clicked notifications, etc, and potentially allows showing a GUI.

   :param config_name: The name of the Maestral configuration to use.
   :param log_to_stdout: If ``True``, write logs to stdout.
   :param start_sync: If ``True``, start syncing once the daemon has started.
   :raises: :class:`RuntimeError` if a daemon for the given ``config_name`` is already
       running.


.. function:: start_maestral_daemon_process(config_name: str = 'maestral', log_to_stdout: bool = False, start_sync: bool = False, detach: bool = True) -> Start

   Starts the Maestral daemon in a new process by calling :func:`start_maestral_daemon`.
   Startup is race free: there will never be two daemons running for the same config.
   This function requires that ``sys.executable`` points to a Python executable and
   therefore may not work "frozen" apps.

   :param config_name: The name of the Maestral configuration to use.
   :param log_to_stdout: If ``True``, write logs to stdout.
   :param start_sync: If ``True``, start syncing once the daemon has started.
   :param detach: If ``True``, the daemon process will be detached. If ``False``,
       the daemon processes will run in the same session as the current process.
   :returns: ``Start.Ok`` if successful, ``Start.AlreadyRunning`` if the daemon was
       already running or ``Start.Failed`` if startup failed. It is possible that
       Start.Ok is returned instead of Start.AlreadyRunning in case of a race.


.. function:: stop_maestral_daemon_process(config_name: str = 'maestral', timeout: float = 10) -> Stop

   Stops a maestral daemon process by finding its PID and shutting it down.

   This function first tries to shut down Maestral gracefully. If this fails and we
   know its PID, it will send SIGTERM. If that fails as well, it will send SIGKILL to
   the process.

   :param config_name: The name of the Maestral configuration to use.
   :param timeout: Number of sec to wait for daemon to shut down before killing it.
   :returns: ``Stop.Ok`` if successful, ``Stop.Killed`` if killed, ``Stop.NotRunning``
       if the daemon was not running and ``Exit.Failed`` if killing the process failed
       because we could not retrieve its PID.


.. py:class:: MaestralProxy(config_name: str = 'maestral', fallback: bool = False)

   A Proxy to the Maestral daemon. All methods and properties of Maestral's public API
   are accessible and calls / access will be forwarded to the corresponding Maestral
   instance. This class can be used as a context manager to close the connection to the
   daemon on exit.

   :Example:

       Use MaestralProxy as a context manager:

       >>> with MaestralProxy() as m:
       ...     print(m.status)

       Use MaestralProxy directly:

       >>> m = MaestralProxy()
       >>> print(m.status)
       >>> m._disconnect()

   :param config_name: The name of the Maestral configuration to use.
   :param fallback: If ``True``, a new instance of Maestral will created in the current
       process when the daemon is not running.
   :raises: :class:`Pyro5.errors.CommunicationError` if the daemon is running but
       cannot be reached or if the daemon is not running and ``fallback`` is ``False``.


